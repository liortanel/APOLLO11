// Three.js r160 - https://github.com/mrdoob/three.js
'use strict';var THREE={REVISION:"160"};self.Float32Array||(self.Float32Array=Array),self.Uint16Array||(self.Uint16Array=Array);

class Vector3{
    constructor(t=0,e=0,n=0){this.x=t,this.y=e,this.z=n}
    set(t,e,n){this.x=t;this.y=e;this.z=n;return this}
    copy(t){this.x=t.x;this.y=t.y;this.z=t.z;return this}
    normalize(){
        const length=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);
        if(length>0){
            this.x/=length;this.y/=length;this.z/=length;
        }
        return this;
    }
    applyEuler(euler){
        // Implementación básica de applyEuler
        const x=this.x,y=this.y,z=this.z;
        const a=Math.cos(euler.x),b=Math.sin(euler.x);
        const c=Math.cos(euler.y),d=Math.sin(euler.y);
        const e=Math.cos(euler.z),f=Math.sin(euler.z);
        
        this.x=x*(c*e)-y*(c*f)+z*d;
        this.y=x*(a*f+b*d*e)+y*(a*e-b*d*f)-z*(b*c);
        this.z=x*(b*f-a*d*e)+y*(b*e+a*d*f)+z*(a*c);
        
        return this;
    }
}

class Color{constructor(r,g,b){this.r=r||0;this.g=g||0;this.b=b||0}setHex(hex){hex=Math.floor(hex);this.r=(hex>>16&255)/255;this.g=(hex>>8&255)/255;this.b=(hex&255)/255;return this}}

class Object3D{
    constructor(){
        this.position=new Vector3();
        this.rotation=new Euler();
        this.children=[];
    }
    add(t){this.children.push(t)}
    remove(t){const e=this.children.indexOf(t);-1!==e&&this.children.splice(e,1)}
}

class Euler{
    constructor(x=0,y=0,z=0,order='XYZ'){
        this.x=x;this.y=y;this.z=z;this.order=order;
    }
    set(x,y,z){this.x=x;this.y=y;this.z=z;return this}
}

class Geometry{constructor(){this.vertices=[];this.faces=[]}}

class PlaneGeometry extends Geometry{
    constructor(width=1,height=1){
        super();
        this.width=width;
        this.height=height;
    }
}

class BoxGeometry extends Geometry{
    constructor(width=1,height=1,depth=1){
        super();
        this.width=width;
        this.height=height;
        this.depth=depth;
    }
}

class Material{constructor(parameters={}){this.color=new Color(1,1,1)}}

class MeshStandardMaterial extends Material{
    constructor(parameters={}){
        super();
        this.roughness=parameters.roughness!==undefined?parameters.roughness:1;
        this.metalness=parameters.metalness!==undefined?parameters.metalness:0;
        if(parameters.color!==undefined)this.color.setHex(parameters.color);
    }
}

class Mesh{
    constructor(geometry,material){
        this.geometry=geometry;
        this.material=material;
        this.position=new Vector3();
        this.rotation=new Euler();
    }
}

class Scene{constructor(){this.children=[];this.background=null}add(t){this.children.push(t)}remove(t){const e=this.children.indexOf(t);-1!==e&&this.children.splice(e,1)}}

class Matrix4 {
    constructor() {
        this.elements = [
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ];
    }

    makeRotationFromEuler(euler) {
        const te = this.elements;
        const x = euler.x, y = euler.y, z = euler.z;
        const a = Math.cos(x), b = Math.sin(x);
        const c = Math.cos(y), d = Math.sin(y);
        const e = Math.cos(z), f = Math.sin(z);

        te[0] = c * e;
        te[4] = -c * f;
        te[8] = d;

        te[1] = a * f + b * d * e;
        te[5] = a * e - b * d * f;
        te[9] = -b * c;

        te[2] = b * f - a * d * e;
        te[6] = b * e + a * d * f;
        te[10] = a * c;

        return this;
    }

    makeTranslation(x, y, z) {
        this.elements[12] = x;
        this.elements[13] = y;
        this.elements[14] = z;
        return this;
    }
}

class PerspectiveCamera{
    constructor(fov=50,aspect=1,near=.1,far=2000){
        this.fov=fov;
        this.aspect=aspect;
        this.near=near;
        this.far=far;
        this.position=new Vector3();
        this.rotation=new Euler();
        this.matrix = new Matrix4();
        this.projectionMatrix = new Matrix4();
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix(){
        const near = this.near;
        const far = this.far;
        const fov = this.fov * (Math.PI / 180);
        const height = 2 * Math.tan(fov / 2) * near;
        const width = height * this.aspect;

        const x = width / 2;
        const y = height / 2;

        this.projectionMatrix.elements = [
            near/x, 0, 0, 0,
            0, near/y, 0, 0,
            0, 0, -(far+near)/(far-near), -1,
            0, 0, -2*far*near/(far-near), 0
        ];
    }
}

class Light extends Object3D{constructor(color,intensity=1){super();this.color=new Color();if(color!==undefined)this.color.setHex(color);this.intensity=intensity}}

class AmbientLight extends Light{constructor(color,intensity){super(color,intensity)}}

class DirectionalLight extends Light{
    constructor(color,intensity){
        super(color,intensity);
        this.position=new Vector3();
        this.target=new Object3D();
    }
    normalize(){this.position.normalize();return this}
}

class WebGLRenderer{
    constructor(parameters = {}) {
        console.log('Inicializando WebGLRenderer');
        this.domElement = document.createElement('canvas');
        this.context = this.domElement.getContext('webgl', {
            alpha: false,
            antialias: true
        });

        if (!this.context) {
            console.error('WebGL no disponible');
            return;
        }

        const gl = this.context;
        console.log('Contexto WebGL creado');

        // Configuración básica
        gl.clearColor(0.529, 0.808, 0.922, 1.0); // Azul cielo
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);

        // Shaders para renderizado 3D
        const vsSource = `
            attribute vec3 position;
            attribute vec3 normal;
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            void main() {
                vNormal = normal;
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fsSource = `
            precision mediump float;
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform vec3 color;
            
            void main() {
                vec3 light = normalize(vec3(1.0, 1.0, 1.0));
                float intensity = max(dot(normalize(vNormal), light), 0.0);
                vec3 finalColor = color * (0.3 + 0.7 * intensity);
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // Crear y compilar shaders
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vsSource);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fsSource);
        gl.compileShader(fragmentShader);

        // Crear programa
        this.program = gl.createProgram();
        gl.attachShader(this.program, vertexShader);
        gl.attachShader(this.program, fragmentShader);
        gl.linkProgram(this.program);

        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
            console.error('Error al inicializar shaders:', gl.getProgramInfoLog(this.program));
            return;
        }

        gl.useProgram(this.program);
        console.log('Shaders inicializados correctamente');

        // Obtener ubicaciones de atributos y uniformes
        this.attributes = {
            position: gl.getAttribLocation(this.program, 'position'),
            normal: gl.getAttribLocation(this.program, 'normal')
        };

        this.uniforms = {
            modelViewMatrix: gl.getUniformLocation(this.program, 'modelViewMatrix'),
            projectionMatrix: gl.getUniformLocation(this.program, 'projectionMatrix'),
            color: gl.getUniformLocation(this.program, 'color')
        };

        // Crear buffers para un cubo
        const cubeVertices = new Float32Array([
            // Frente
            -1, -1,  1,   1, -1,  1,   1,  1,  1,  -1,  1,  1,
            // Atrás
            -1, -1, -1,  -1,  1, -1,   1,  1, -1,   1, -1, -1,
            // Arriba
            -1,  1, -1,  -1,  1,  1,   1,  1,  1,   1,  1, -1,
            // Abajo
            -1, -1, -1,   1, -1, -1,   1, -1,  1,  -1, -1,  1,
            // Derecha
             1, -1, -1,   1,  1, -1,   1,  1,  1,   1, -1,  1,
            // Izquierda
            -1, -1, -1,  -1, -1,  1,  -1,  1,  1,  -1,  1, -1,
        ]);

        const cubeNormals = new Float32Array([
            // Frente
            0, 0, 1,   0, 0, 1,   0, 0, 1,   0, 0, 1,
            // Atrás
            0, 0,-1,   0, 0,-1,   0, 0,-1,   0, 0,-1,
            // Arriba
            0, 1, 0,   0, 1, 0,   0, 1, 0,   0, 1, 0,
            // Abajo
            0,-1, 0,   0,-1, 0,   0,-1, 0,   0,-1, 0,
            // Derecha
            1, 0, 0,   1, 0, 0,   1, 0, 0,   1, 0, 0,
            // Izquierda
           -1, 0, 0,  -1, 0, 0,  -1, 0, 0,  -1, 0, 0,
        ]);

        const cubeIndices = new Uint16Array([
            0,  1,  2,    0,  2,  3,  // Frente
            4,  5,  6,    4,  6,  7,  // Atrás
            8,  9,  10,   8,  10, 11, // Arriba
            12, 13, 14,   12, 14, 15, // Abajo
            16, 17, 18,   16, 18, 19, // Derecha
            20, 21, 22,   20, 22, 23  // Izquierda
        ]);

        // Crear y llenar buffers
        this.vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);

        this.normalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, cubeNormals, gl.STATIC_DRAW);

        this.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);

        this.indexCount = cubeIndices.length;
        console.log('Buffers creados');
    }

    setSize(width, height) {
        console.log('Estableciendo tamaño:', width, height);
        this.domElement.width = width;
        this.domElement.height = height;
        this.context.viewport(0, 0, width, height);
    }

    setPixelRatio(value) {
        console.log('Estableciendo pixel ratio:', value);
        this.pixelRatio = value;
    }

    render(scene, camera) {
        console.log('Renderizando escena');
        const gl = this.context;
        
        // Limpiar el canvas
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Configurar atributos
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(this.attributes.position, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.attributes.position);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
        gl.vertexAttribPointer(this.attributes.normal, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.attributes.normal);

        // Configurar matrices
        const projMatrix = camera.projectionMatrix.elements;
        gl.uniformMatrix4fv(this.uniforms.projectionMatrix, false, projMatrix);

        // Renderizar cada objeto
        scene.children.forEach(object => {
            if (object instanceof Mesh) {
                // Configurar matriz de modelo-vista
                const modelViewMatrix = new Matrix4();
                modelViewMatrix.makeTranslation(
                    object.position.x,
                    object.position.y,
                    object.position.z
                );
                gl.uniformMatrix4fv(this.uniforms.modelViewMatrix, false, modelViewMatrix.elements);

                // Configurar color
                const color = object.material.color;
                gl.uniform3f(this.uniforms.color, color.r, color.g, color.b);

                // Dibujar
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
            }
        });
        
        console.log('Renderizado completado');
    }
}

class EventDispatcher{
    addEventListener(t,e){this._listeners=this._listeners||{};this._listeners[t]=this._listeners[t]||[];this._listeners[t].push(e)}
    dispatchEvent(t){if(this._listeners===undefined||this._listeners[t.type]===undefined)return;const e=this._listeners[t.type];for(let n=0,i=e.length;n<i;n++)e[n].call(this,t)}
}

THREE.Vector3=Vector3;
THREE.Color=Color;
THREE.Object3D=Object3D;
THREE.Euler=Euler;
THREE.Geometry=Geometry;
THREE.PlaneGeometry=PlaneGeometry;
THREE.BoxGeometry=BoxGeometry;
THREE.Material=Material;
THREE.MeshStandardMaterial=MeshStandardMaterial;
THREE.Mesh=Mesh;
THREE.Scene=Scene;
THREE.PerspectiveCamera=PerspectiveCamera;
THREE.Light=Light;
THREE.AmbientLight=AmbientLight;
THREE.DirectionalLight=DirectionalLight;
THREE.WebGLRenderer=WebGLRenderer;
THREE.EventDispatcher=EventDispatcher;
THREE.Matrix4 = Matrix4; 